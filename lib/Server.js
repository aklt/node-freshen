// Generated by CoffeeScript 1.12.3
var Api, Server, WebSocket, addHttpMethods, apiCommand, assert, coffee, fs, http, info, log, loggerConf, note, path, ref, url, warn;

fs = require('fs');

url = require('url');

path = require('path');

http = require('http');

assert = require('assert');

coffee = require('coffee-script');

WebSocket = require('ws');

ref = require('./logger'), loggerConf = ref.loggerConf, info = ref.info, note = ref.note, log = ref.log, warn = ref.warn;

addHttpMethods = require('./addHttpMethods');

addHttpMethods();

apiCommand = require('./apiCommand');

Api = require('./Api');

Server = (function() {
  function Server(conf) {
    var headers, ref1, ref2;
    this.conf = conf;
    assert(this.conf.url, "Need conf.url");
    assert(this.conf.mimeTypes, "Need mime types");
    loggerConf(this.conf);
    ref1 = this.conf, this.url = ref1.url, this.mimeTypes = ref1.mimeTypes, this.mimeAdd = ref1.mimeAdd;
    ref2 = url.parse(this.url), this.hostname = ref2.hostname, this.port = ref2.port;
    this.port || (this.port = '80');
    this.port = parseInt(this.port, 10);
    headers = {
      'Cache-Control': 'private, max-age=0, must-revalidate'
    };
    this.httpServer = http.createServer((function(_this) {
      return function(req, res) {
        var fileName, filePath, suffix;
        res.headers = headers;
        if (Api.match(req.url)) {
          return Api.handle(req, res);
        }
        fileName = req.url.replace(/\?.*/, '');
        if (fileName[fileName.length - 1] === '/') {
          fileName += 'index.html';
        }
        note(req.method + " " + fileName);
        filePath = _this.conf.root + "/" + (fileName.slice(1));
        suffix = /(\w*)$/.exec(fileName)[1];
        return fs.readFile(filePath, function(err, data) {
          var mimeType;
          if (err) {
            warn(err + '');
            res.headers['Content-Type'] = 'text/plain';
            res.writeHead(400, res.headers);
            return res.end(err.toString());
          }
          mimeType = _this.conf.mimeTypes[suffix];
          if (mimeType === 'text/html') {
            data = _this.injector(data);
          }
          res.headers['Content-Type'] = mimeType || 'text/plain';
          res.writeHead(200, res.headers);
          return res.end(data);
        });
      };
    })(this));
    this.wsServer = new WebSocket.Server({
      server: this.httpServer,
      path: '/'
    });
    this.wsServer.on('connection', function(ws) {
      return log("Connection accepted");
    });
  }

  Server.prototype.start = function(next) {
    var listen, maxTries;
    maxTries = 20;
    listen = (function(_this) {
      return function() {
        return _this.httpServer.listen(_this.port, _this.hostname, function(err) {
          if (err) {
            return next(err);
          }
        });
      };
    })(this);
    this.httpServer.on('listening', (function(_this) {
      return function() {
        var msgListen, url2, urlObj;
        msgListen = "Listening to " + _this.url;
        if (maxTries < 20) {
          urlObj = url.parse(_this.url);
          url2 = urlObj.protocol + "//" + urlObj.hostname + ":" + _this.port;
          msgListen = "Listening to " + url2 + " (changed from " + _this.url + ")";
          _this.url = url2;
        }
        _this.injector = _this.makeCoffeeInjector([path.normalize(__dirname + "/../lib/script.js")]);
        info(msgListen);
        return (next || function() {})(0);
      };
    })(this));
    this.httpServer.removeAllListeners('error');
    this.httpServer.on('error', (function(_this) {
      return function(err) {
        var error;
        error = err.toString();
        if (error) {
          if (/EADDRINUSE/.test(error)) {
            warn(error);
            _this.port += 1;
            maxTries -= 1;
            if (maxTries > 0) {
              return listen();
            }
          }
          return next(error);
        }
      };
    })(this));
    return listen();
  };

  Server.prototype.stop = function(next) {
    return this.httpServer.close((function(_this) {
      return function() {
        return _this.httpServer = null;
      };
    })(this));
  };

  Server.prototype.send = function(data) {
    info("Sending " + data + " to client(s)");
    return this.wsServer.clients.forEach(function(client) {
      if (client.readyState === WebSocket.OPEN) {
        return client.send(data);
      }
    });
  };

  Server.prototype.makeCoffeeInjector = function(filesToInject) {
    var cs, fileToInject, j, js, len;
    js = '';
    for (j = 0, len = filesToInject.length; j < len; j++) {
      fileToInject = filesToInject[j];
      cs = fs.readFileSync(fileToInject).toString().replace('<<URL>>', this.url.replace(/^http/, 'ws'));
      if (/\.coffee$/.test(fileToInject)) {
        cs = coffee.compile(cs, {
          bare: true
        });
      }
      js += "<script>\n" + cs + "\n</script>\n";
    }
    return function(data) {
      var i, k, lastBody, len1, line, lines;
      lines = data.toString().split(/\r\n|\n/g);
      lastBody = -1;
      for (i = k = 0, len1 = lines.length; k < len1; i = ++k) {
        line = lines[i];
        if (/<\/body>/i.test(line)) {
          lastBody = i;
        }
      }
      if (lastBody > -1) {
        lines[lastBody] = lines[lastBody].replace(/<\/body>/i, js + "</body>");
      }
      return lines.join('\n');
    };
  };

  return Server;

})();

module.exports = Server;
